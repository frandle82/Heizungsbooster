substitutions:
  # -----------------------
  # Geräte-Identifikation
  # -----------------------
  device_name: heizungsbooster                   # Name des Geräts (z.B. "heizungsbooster")
  device_friendly_name: Heizungsbooster          # Anzeige-Name des Geräts (z.B. "Heizungsbooster")  

  # -----------------------
  # Sicherheit & Netzwerk
  # -----------------------
  api_encryption_key: !secret api_encryption_key # API Encryption Key (z.B. "base64_encrypted_key_hier_eintragen==")
  ota_password: !secret ota_password             # Passwort für den OTA Update (z.B. "InM2TlqVfJe4")
  ap_ssid: ${device_name}_AP                     # SSID für den Access Point (z.B. "shys-heizungsbooster_AP")
  ap_password: !secret ap_password               # Passwort für den Access Point (z.B. "InM2TlqVfJe4")

  # -----------------------
  # Lüfter Konfiguration
  # -----------------------
  pin_fan: GPIO13                                # Pin für Lüfter PWM Steuersignal
  fan_pwm_frequency: 25000 Hz                    # 4-Pol PC-Lüfter: 25000Hz // 3-Pol Lüfter mit Mosfet Schaltung: 1000Hz (bei Problemen 500-3000Hz testen)

  # ---------------------------------
  # Temperatur-Sensor Konfiguration
  # ---------------------------------
  heizung1_temp_entity: "climate.wohnzimmer_heizung_links"
  heizung2_temp_entity: "climate.wohnzimmer_heizung_rechts"
  steuerung_temp_entity: "climate.wohnzimmer"
  raum_temp_entity: "sensor.wohnzimmer_temp_temperature"

  # -----------------------
  # Standardwerte (Initial Values)
  # -----------------------
  initial_deadband: "0.5"
  initial_fully_open_temp: "2.0"
  initial_temp_threshold: "3.0"                       # Temperaturdifferenz zwischen Heizung und Raum, ab der der Lüfter eingeschaltet wird (z.B. 3°C)
  initial_default_raum_temp: "21.0"                   # Fallback-Wert wenn kein Wert von HA oder DS18B20 verfügbar ist
  initial_man_fan_speed: "50.0"                       # Manuelle Lüftergeschwindigkeit (für MANUAL-Modus)

  #------------------------
  # Steuerungswerte
  #------------------------

  # Kennlinie Heizbetrieb: ΔT-Stützpunkte (°C) und Speed (%)
  heat_dt0: "0.3"   # unterhalb davon: aus (kalt/ineffizient)
  heat_dt1: "0.8"
  heat_dt2: "2.0"
  heat_dt3: "4.1"
  heat_dt4: "6.0"

  heat_s0: "0"
  heat_s1: "22"     # psycho LOW
  heat_s2: "38"     # MID
  heat_s3: "55"     # HIGH
  heat_s4: "80"     # gedeckeltes MAX

  # Plateau/Abflachung ab Ts+dead: deutlich flacher (leiser)
  plat_dt1: "0.5"
  plat_dt2: "2.0"
  plat_dt3: "5.0"

  plat_s1: "22"
  plat_s2: "38"
  plat_s3: "55"

  # -----------------------
  # Timing
  # -----------------------
  automatik_interval: 20s       # Intervall für die automatische Steuerung (z.B. 10s)
  sensor_update_interval: 9s    # Sollte etwas kürzer sein als automatik_interval

  # --------------------------------------------------------------------------------------------
  # --------------------------------------------------------------------------------------------
  # Konfiguration ENDE
  # --------------------------------------------------------------------------------------------
  # --------------------------------------------------------------------------------------------

esphome:
  name: ${device_name}
  friendly_name: ${device_friendly_name}

esp32:
  board: nodemcu-32s
  framework:
    type: arduino

logger:

api:
  encryption:
    key: ${api_encryption_key}

ota:
  - platform: esphome
    password: ${ota_password}
  
wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password

  ap:
    ssid: ${ap_ssid}
    password: ${ap_password}

captive_portal:

web_server:
  port: 80
  include_internal: false
  log: false

globals:
  - id: psycho_speed_filt
    type: float
    restore_value: no
    initial_value: '0'

  - id: last_speed
    type: int
    restore_value: no
    initial_value: '0'

  - id: fan_on_since
    type: uint32_t
    restore_value: no
    initial_value: '0'

  - id: last_heat_ms
    type: uint32_t
    restore_value: no
    initial_value: '0'

  - id: proxy_on_glob
    type: bool
    restore_value: no
    initial_value: 'false'
  
switch:
  - platform: restart
    name: Neustart
    id: reboot

fan:
  - platform: speed
    output: pwm_output
    name: "Ventilator"
    id: heizung_luefter
    speed_count: 100
    restore_mode: ALWAYS_OFF

output:
  - platform: ledc
    frequency: ${fan_pwm_frequency}
    pin: ${pin_fan}
    id: pwm_output

interval:
  # Automatik-Steuerung
  - interval: ${automatik_interval}
    then:
      - script.execute: automatik_steuerung

text_sensor:
  - platform: template
    name: "Heizungsbooster Status"
    id: booster_state
  - platform: template
    name: "Heizungsbooster Diagnose"
    id: booster_diag
  - platform: homeassistant
    id: hvac_action
    entity_id: ${steuerung_temp_entity}
    attribute: hvac_action

binary_sensor:
  - platform: homeassistant
    name: "Fenster Status"
    entity_id: ${steuerung_temp_entity}
    attribute: window_open
    id: fenster_status
    on_state:
      - script.execute: automatik_steuerung

time:
  - platform: homeassistant
    id: ha_time

sensor:
  - platform: template
    name: "Luefterleistung"
    id: luefterleistung
    unit_of_measurement: "%"
    accuracy_decimals: 0
    update_interval: never

  - platform: dht
    pin: GPIO23
    temperature:
      name: "Heizung Konvektions-Proxy"
      id: heizung_surface
      filters:
        # DHT ist träge & verrauscht → starkes Glätten
        - sliding_window_moving_average:
            window_size: 5
            send_every: 1
        # unrealistische Werte blockieren
        - lambda: |-
            if (x < 15.0 || x > 80.0) return NAN;
            return x;
    update_interval: 60s
    
  # Temperatur-Sensor Heizung1
  - platform: homeassistant
    name: "Heizkörper1 Temperatur"
    entity_id: ${heizung1_temp_entity}
    attribute: current_temperature
    internal: true
    id: heizung1_temp

  # Temperatur-Sensor Heizung2
  - platform: homeassistant
    name: "Heizkörper2 Temperatur"
    entity_id: ${heizung2_temp_entity}
    attribute: current_temperature
    internal: true
    id: heizung2_temp

  # eingestellte Raumtemperatur
  - platform: homeassistant
    name: "Solltemperatur"
    entity_id: ${steuerung_temp_entity}
    attribute: temperature
    id: steuerung_temp

  # Raumtemperatur-Sensor aus HA
  - platform: homeassistant
    name: "Raumtemperatur"
    entity_id: ${raum_temp_entity}
    id: raum_temp

  - platform: template
    name: "Heizungstemperatur"
    id: heizung_temp
    update_interval: ${sensor_update_interval}
    accuracy_decimals: 1
    unit_of_measurement: "°C"
    lambda: |-
      float h1 = id(heizung1_temp).state;
      float h2 = id(heizung2_temp).state;
      if (isnan(h1)) return h2;
      if (isnan(h2)) return h1;
      return (h1 > h2) ? h1 : h2;

  - platform: homeassistant
    name: "Temperatur_Slope"
    entity_id: sensor.wohnzimmer_temperature_slope
    id: temperatur_slope
    internal: true

  - platform: homeassistant
    name: "MPC_Gain"
    entity_id: sensor.wohnzimmer_mpc_gain
    id: mpc_gain
    internal: true

  - platform: homeassistant
    name: "MPC_Loss"
    entity_id: sensor.wohnzimmer_mpc_loss
    id: mpc_loss
    internal: true


number:
  - platform: template
    name: "Deadband"
    id: deadband_val
    min_value: 0.0
    max_value: 2.0
    step: 0.1
    initial_value: ${initial_deadband}
    optimistic: true
    restore_value: true
    on_value:
      - script.execute: automatik_steuerung

  - platform: template
    name: "Hysterese"
    id: temp_threshold
    min_value: 0.0
    max_value: 2.0
    step: 0.1
    initial_value: ${initial_fully_open_temp}
    optimistic: true
    restore_value: true
    on_value:
      - script.execute: automatik_steuerung

  # Manuelle Lüftergeschwindigkeit (für MANUAL-Modus)
  - platform: template
    name: "man Lueftergeschwindigkeit"
    id: man_fan_speed
    min_value: 0.0
    max_value: 100.0
    step: 10.0
    initial_value: ${initial_man_fan_speed}
    optimistic: true
    restore_value: true
    on_value:
      - lambda: |-
          std::string mode = id(fan_mode).current_option();
          if (mode == "manual") {
            // MANUAL: Auf manuelle Geschwindigkeit setzen
            id(apply_man_fan_speed).execute();

          } else if (mode == "auto") {
            // AUTO: Automatik-Logik ausführen
            id(automatik_steuerung).execute();
          }

select:
  # Interner Select für Betriebsmodus
  - platform: template
    id: fan_mode
    name: "Betriebsmodus"
    internal: false
    options:
      - "off"
      - "manual"
      - "auto"
    initial_option: "auto"
    optimistic: true
    restore_value: true
    on_value:
      - lambda: |-
          std::string mode = id(fan_mode).current_option();

          if (mode == "off") {
            // OFF: Lüfter ausschalten
            auto call = id(heizung_luefter).turn_off();
            call.perform();

          } else if (mode == "manual") {
            // MANUAL: Auf manuelle Geschwindigkeit setzen
            id(apply_man_fan_speed).execute();

          } else if (mode == "auto") {
            // AUTO: Automatik-Logik ausführen
            id(automatik_steuerung).execute();
          }

script:
  # Lüftergeschwindigkeit vom Number in den Fan übernehmen (nur im MANUAL-Modus)
  - id: apply_man_fan_speed
    then:
      - lambda: |-
          std::string mode = id(fan_mode).current_option();
          if (mode != "manual") return;

          int speed_value = (int)id(man_fan_speed).state;

          if (speed_value < 1) {
            id(heizung_luefter).turn_off().perform();
          } else {
            auto call = id(heizung_luefter).turn_on();
            call.set_speed(speed_value);
            call.perform();
            id(luefterleistung).publish_state(speed_value);
          }

  # Betriebsmodus wechseln: off -> manual -> auto -> off
  - id: switch_mode
    then:
      - lambda: |-
          std::string current_mode = id(fan_mode).current_option();
          std::string new_mode;

          if (current_mode == "off") new_mode = "manual";
          else if (current_mode == "manual") new_mode = "auto";
          else new_mode = "off";

          id(fan_mode).publish_state(new_mode);

  # Manuelle Geschwindigkeit in 25% Stufen ändern
  - id: adjust_manual_speed
    then:
      - lambda: |-
          std::string mode = id(fan_mode).current_option();
          if (mode != "manual") return;

          float current_speed = id(man_fan_speed).state;
          float new_speed;

          if (current_speed < 12.5) new_speed = 25.0;
          else if (current_speed < 37.5) new_speed = 50.0;
          else if (current_speed < 62.5) new_speed = 75.0;
          else if (current_speed < 87.5) new_speed = 100.0;
          else new_speed = 0.0;

          id(man_fan_speed).publish_state(new_speed);

  # Automatik-Steuerung
  - id: automatik_steuerung
    then:
      - lambda: |-
          /* =========================================================
             MODUS & SICHERHEIT
          ========================================================= */
          if (id(fan_mode).current_option() != "auto") return;

          if (id(fenster_status).state) {
            id(heizung_luefter).turn_off().perform();
            id(booster_state).publish_state("Fenster offen");
            id(booster_diag).publish_state("OFF: window");
            return;
          }

          if (!id(raum_temp).has_state() || !id(heizung_temp).has_state()) return;

          float Tr = id(raum_temp).state;
          float Th = id(heizung_temp).state;
          if (isnan(Tr) || isnan(Th)) return;

          float delta = Th - Tr;
          float delta_heat = Th - Tr;
          bool heat_available = (delta_heat >= 0.7f);

          float Ts   = id(steuerung_temp).has_state() ? id(steuerung_temp).state : Tr;
          float dead = id(deadband_val).state;
          float hyst = id(temp_threshold).state;
          float e = Ts - Tr;  // >0: unter Soll, <=0: am/über Soll
          bool soft_zone = (e >= -0.2f && e <= 0.2f);
          bool boost_allowed = (e >= 1.0f);
          bool near_setpoint_1K = (e < 1.0f);
          float soft_min = 38.0f;
          float soft_max = 45.0f;

          auto *temp_slope_sensor = id(temperatur_slope);
          auto *mpc_gain_sensor = id(mpc_gain);
          auto *mpc_loss_sensor = id(mpc_loss);
          float temp_slope = 
            (temp_slope_sensor->has_state() && !isnan(temp_slope_sensor->state)) ? temp_slope_sensor->state : 0.0f;
          float mpc_gain = 
           (mpc_gain_sensor->has_state() && !isnan(mpc_gain_sensor->state)) ? mpc_gain_sensor->state : 0.0f;
          float mpc_loss = 
            (mpc_loss_sensor->has_state() && !isnan(mpc_loss_sensor->state)) ? mpc_loss_sensor->state : 0.0f;
          bool mpc_heating_active = (mpc_gain > 0.01f);
          bool mpc_effective = (temp_slope < mpc_gain * 0.8f);
          bool comfort_enabled = (!mpc_heating_active || (mpc_loss > mpc_gain));


          /* =========================================================
             ZUSTÄNDE & DIFFERENZEN
          ========================================================= */
          bool heating_active = false;

          // Optional: hvac_action als zusätzliche Heizinformation
          bool hvac_reports_heat = false;
          if (id(hvac_action).has_state()) {
            hvac_reports_heat = (id(hvac_action).state == "heating");
          }

          // Zeitfenster "war kürzlich heizen"
          uint32_t now = millis();
          bool recently_heating = (id(last_heat_ms) > 0) && ((now - id(last_heat_ms)) < (15u * 60u * 1000u));

          /* =========================================================
             ADAPTIVE PROXY-LOGIK (DHT als Konvektionsindikator)
          ========================================================= */
          bool proxy_valid = id(heizung_surface).has_state() && !isnan(id(heizung_surface).state);
          float Tproxy = proxy_valid ? id(heizung_surface).state : NAN;
          float delta_proxy = proxy_valid ? (Tproxy - Tr) : NAN;
          float delta_eff = std::max(Th - Tr, proxy_valid ? delta_proxy : -1000.0f);
          bool usable_heat = (Th > Tr + dead + 0.8f) || (proxy_valid && (Tproxy > Tr + 0.8f));

          heating_active = (Tr < Ts - dead) && usable_heat;

          float proxy_on_th, proxy_off_th;
          if (delta >= 3.0f)      { proxy_on_th = 0.6f; proxy_off_th = 0.4f; }
          else if (delta >= 2.0f) { proxy_on_th = 0.8f; proxy_off_th = 0.6f; }
          else if (delta >= 1.0f) { proxy_on_th = 1.0f; proxy_off_th = 0.8f; }
          else                   { proxy_on_th = 1.2f; proxy_off_th = 1.0f; }

          if (!id(proxy_on_glob)) {
            if (proxy_valid && delta_proxy >= proxy_on_th) id(proxy_on_glob) = true;
          } else {
            if (!proxy_valid || delta_proxy <= proxy_off_th) id(proxy_on_glob) = false;
          }

          // Restwärme streng thermodynamisch (Proxy nicht verwenden)
          bool restwaerme =
            (Th > Tr + dead + hyst) &&
            (Tr < Ts) &&
            (recently_heating || hvac_reports_heat);

          float transport_min_speed = 18.0f;

          /* =========================================================
             KENNLINE – HILFSFUNKTIONEN
          ========================================================= */
          auto lerp = [](float a, float b, float t) {
            return a + (b - a) * t;
          };
          auto clamp01 = [](float x) {
            return std::clamp(x, 0.0f, 1.0f);
          };

          auto piecewise = [&](float x) {
            if (x <= ${heat_dt0}) return (float)${heat_s0};
            if (x <= ${heat_dt1}) return lerp(${heat_s0}, ${heat_s1}, (x - ${heat_dt0}) / (${heat_dt1} - ${heat_dt0}));
            if (x <= ${heat_dt2}) return lerp(${heat_s1}, ${heat_s2}, (x - ${heat_dt1}) / (${heat_dt2} - ${heat_dt1}));
            if (x <= ${heat_dt3}) return lerp(${heat_s2}, ${heat_s3}, (x - ${heat_dt2}) / (${heat_dt3} - ${heat_dt2}));
            if (x <= ${heat_dt4}) return lerp(${heat_s3}, ${heat_s4}, (x - ${heat_dt3}) / (${heat_dt4} - ${heat_dt3}));
            return (float)${heat_s4};
          };

          /* =========================================================
            LÜFTERBERECHNUNG (kontinuierlich)
          ========================================================= */
          float speed_cont = 0.0f;
          const float min_tech_speed = 15.0f;
          const float high_speed_cap = 55.0f;
          float base_common = piecewise(std::max(0.0f, delta_eff));

          // Proxy dient ausschließlich als Freigabe für hohe Drehzahlen
          bool high_speed_allowed = id(proxy_on_glob) && (mpc_heating_active ? true : (e > 0.0f));
          if (!high_speed_allowed && base_common > high_speed_cap) base_common = high_speed_cap;
          if (proxy_valid && (delta_proxy < (proxy_on_th + 0.15f)) && base_common > high_speed_cap) {
            base_common = high_speed_cap;
          }

          float comfort = 1.0f;
          if (comfort_enabled) {
            comfort = clamp01(delta_eff / 3.0f);
            comfort = 0.4f + 0.6f * comfort;
          }

          const char *zone = "OFF";

          /* ---- 1) HEIZBETRIEB ---- */
          if (e > 0.2f) {
            zone = "HEAT";
            if (heating_active && delta >= 0.3f) {
              id(last_heat_ms) = millis();
            }

            float base = base_common;
            if (!(mpc_heating_active && heat_available)) {
              if (!boost_allowed) {
                base = std::min(base, 55.0f);
              } else {
                float t = clamp01((e - 1.0f) / 0.5f);
                float boost_cap = 55.0f + t * (80.0f - 55.0f);
                base = std::min(base, boost_cap);
              }

              if (boost_allowed && delta >= 3.5f) {
                base = std::min(base * 1.20f, 80.0f);
              }
            }

            base *= comfort;
            if (heat_available) {
              base = std::max(base, transport_min_speed);
            } else {
              base = 0.0f;
            }

            speed_cont = std::clamp(base, 0.0f, 100.0f);
          }

          /* ---- 2) SOFT-CIRCULATION ---- */
          else if (soft_zone || (e < -0.2f && restwaerme)) {
            zone = "SOFT";
            if (heat_available || recently_heating) {
              float base = base_common * comfort;
              if (!(mpc_heating_active && heat_available)) {
                base = std::clamp(base, soft_min, soft_max);
              }
              speed_cont = std::clamp(base, 0.0f, 100.0f);
            } else {
              speed_cont = 0.0f;
            }
          }

          /* ---- 3) AUS (mit Mindestlaufzeit) ---- */
          else {
            speed_cont = 0.0f;
          }

          if (!boost_allowed && speed_cont > 55.0f) {
            speed_cont = 55.0f;
          }

          /* =========================================================
             PHYSIKALISCHE INVARIANTE – WÄRMEABTRANSPORT
             ========================================================= */
          if (heat_available) {
            speed_cont = std::max(speed_cont, transport_min_speed);
          } else {
            speed_cont = 0.0f;
          }

          /* =========================================================
             PSYCHOAKUSTIK (P8 MAX)
          ========================================================= */
          auto quant = [&](int s) {
            if (s < 15) return 0;
            if (s < 30) return 22;
            if (s < 45) return 38;
            if (s < 60) return 55;
            return 70;
          };

          int ramp_up = boost_allowed ? 18 : 12;
          int ramp_down = near_setpoint_1K ? 10 : 3;
          float alpha = near_setpoint_1K ? 0.20f : 0.10f;

          float speed_ramped = speed_cont;
          float last_speed_f = id(psycho_speed_filt);

          if (speed_ramped > last_speed_f)
            speed_ramped = std::min(speed_ramped, last_speed_f + ramp_up);
          else
            speed_ramped = std::max(speed_ramped, last_speed_f - ramp_down);

          id(psycho_speed_filt) =
            id(psycho_speed_filt) * (1.0f - alpha) + speed_ramped * alpha;

          if (speed_cont >= min_tech_speed && id(psycho_speed_filt) < min_tech_speed) {
            id(psycho_speed_filt) = min_tech_speed;
          }

          int speed = (int)roundf(id(psycho_speed_filt));
          if (boost_allowed) {
            speed = (int)(roundf(speed / 5.0f) * 5.0f);
          } else {
            speed = quant(speed);
          }
          if (heat_available && speed <= 0) {
            speed = (int)transport_min_speed;
          }

          if (id(last_speed) <= 0 && speed > 0) {
            id(fan_on_since) = millis();
          }

          if (speed <= 0) {
            id(heizung_luefter).turn_off().perform();
          } else {
            id(heizung_luefter).turn_on().set_speed(speed).perform();
          }
          id(last_speed) = speed;
          id(luefterleistung).publish_state(speed);

          /* =========================================================
             DIAGNOSE
          ========================================================= */
          float effective_share = speed_cont / 100.0f;
          char buf[240];
          snprintf(buf, sizeof(buf),
            "ΔT=%.1fK | Th=%.1f Tr=%.1f Ts=%.1f | e=%.2fK soft=%d boost=%d usable=%d ΔT_eff=%.1fK | ΔT_heat=%.1fK heat_avail=%d | slope=%.3fK/min gain=%.3f loss=%.3f mpc=%d eff=%d | Zone=%s | Komfort=%.2f | Anteil=%.2f | proxy=%.1fK(%s) | Fan=%d%%",
            delta, Th, Tr, Ts, e, soft_zone ? 1 : 0, boost_allowed ? 1 : 0, usable_heat ? 1 : 0, delta_eff,
            delta_heat, heat_available ? 1 : 0,
            temp_slope, mpc_gain, mpc_loss, mpc_heating_active ? 1 : 0, mpc_effective ? 1 : 0,
            zone,
            comfort,
            effective_share,
            (proxy_valid ? delta_proxy : NAN),
            (id(proxy_on_glob) ? "ON" : "OFF"),
            speed
          );
          id(booster_diag).publish_state(buf);

          id(booster_state).publish_state(speed > 0 ? zone : "Aus");


 
