substitutions:
  # -----------------------
  # Geräte-Identifikation
  # -----------------------
  device_name: heizungsbooster                   # Name des Geräts (z.B. "heizungsbooster")
  device_friendly_name: Heizungsbooster          # Anzeige-Name des Geräts (z.B. "Heizungsbooster")  

  # -----------------------
  # Sicherheit & Netzwerk
  # -----------------------
  api_encryption_key: !secret api_encryption_key # API Encryption Key (z.B. "base64_encrypted_key_hier_eintragen==")
  ota_password: !secret ota_password             # Passwort für den OTA Update (z.B. "InM2TlqVfJe4")
  ap_ssid: ${device_name}_AP                     # SSID für den Access Point (z.B. "shys-heizungsbooster_AP")
  ap_password: !secret ap_password               # Passwort für den Access Point (z.B. "InM2TlqVfJe4")

  # -----------------------
  # Lüfter Konfiguration
  # -----------------------
  pin_fan: GPIO13                                # Pin für Lüfter PWM Steuersignal
  fan_pwm_frequency: 25000 Hz                    # 4-Pol PC-Lüfter: 25000Hz // 3-Pol Lüfter mit Mosfet Schaltung: 1000Hz (bei Problemen 500-3000Hz testen)

  # ---------------------------------
  # Temperatur-Sensor Konfiguration
  # ---------------------------------
  heizung1_temp_entity: "climate.wohnzimmer_heizung_links"
  heizung2_temp_entity: "climate.wohnzimmer_heizung_rechts"
  steuerung_temp_entity: "climate.wohnzimmer"
  raum_temp_entity: "sensor.wohnzimmer_temp_temperature"

  # -----------------------
  # Standardwerte (Initial Values)
  # -----------------------
  initial_man_fan_speed: "50.0"                       # Manuelle Lüftergeschwindigkeit (für MANUAL-Modus)

  # -----------------------
  # Timing
  # -----------------------
  automatik_interval: 12s       # Intervall für die automatische Steuerung (z.B. 10s)
  sensor_update_interval: 9s    # Sollte etwas kürzer sein als automatik_interval

  # --------------------------------------------------------------------------------------------
  # --------------------------------------------------------------------------------------------
  # Konfiguration ENDE
  # --------------------------------------------------------------------------------------------
  # --------------------------------------------------------------------------------------------

esphome:
  name: ${device_name}
  friendly_name: ${device_friendly_name}

esp32:
  board: nodemcu-32s
  framework:
    type: arduino

logger:

api:
  encryption:
    key: ${api_encryption_key}

ota:
  - platform: esphome
    password: ${ota_password}
  
wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password

  ap:
    ssid: ${ap_ssid}
    password: ${ap_password}

captive_portal:

web_server:
  port: 80
  include_internal: false
  log: false

globals:
  - id: last_speed
    type: int
    restore_value: no
    initial_value: '0'

  - id: last_heat_ms
    type: uint32_t
    restore_value: no
    initial_value: '0'
  
switch:
  - platform: restart
    name: Neustart
    id: reboot

fan:
  - platform: speed
    output: pwm_output
    name: "Ventilator"
    id: heizung_luefter
    speed_count: 100
    restore_mode: ALWAYS_OFF

output:
  - platform: ledc
    frequency: ${fan_pwm_frequency}
    pin: ${pin_fan}
    id: pwm_output

interval:
  # Automatik-Steuerung
  - interval: ${automatik_interval}
    then:
      - script.execute: automatik_steuerung

text_sensor:
  - platform: template
    name: "Heizungsbooster Status"
    id: booster_state

binary_sensor:
  - platform: homeassistant
    name: "Fenster Status"
    entity_id: ${steuerung_temp_entity}
    attribute: window_open
    id: fenster_status
    on_state:
      - script.execute: automatik_steuerung

sensor:
  - platform: template
    name: "Luefterleistung"
    id: luefterleistung
    unit_of_measurement: "%"
    accuracy_decimals: 0
    update_interval: never

  - platform: dht
    pin: GPIO23
    temperature:
      name: "Heizung Konvektions-Proxy"
      id: heizung_surface
      filters:
        # DHT ist träge & verrauscht → starkes Glätten
        - sliding_window_moving_average:
            window_size: 5
            send_every: 1
        # unrealistische Werte blockieren
        - lambda: |-
            if (x < 15.0 || x > 80.0) return NAN;
            return x;
    update_interval: 60s
    
  # Temperatur-Sensor Heizung1
  - platform: homeassistant
    name: "Heizkörper1 Temperatur"
    entity_id: ${heizung1_temp_entity}
    attribute: current_temperature
    internal: true
    id: heizung1_temp

  # Temperatur-Sensor Heizung2
  - platform: homeassistant
    name: "Heizkörper2 Temperatur"
    entity_id: ${heizung2_temp_entity}
    attribute: current_temperature
    internal: true
    id: heizung2_temp

  # eingestellte Raumtemperatur
  - platform: homeassistant
    name: "Solltemperatur"
    entity_id: ${steuerung_temp_entity}
    attribute: temperature
    id: steuerung_temp

  # Raumtemperatur-Sensor aus HA
  - platform: homeassistant
    name: "Raumtemperatur"
    entity_id: ${raum_temp_entity}
    id: raum_temp

  - platform: template
    name: "Heizungstemperatur"
    id: heizung_temp
    update_interval: ${sensor_update_interval}
    accuracy_decimals: 1
    unit_of_measurement: "°C"
    lambda: |-
      float h1 = id(heizung1_temp).state;
      float h2 = id(heizung2_temp).state;
      if (isnan(h1)) return h2;
      if (isnan(h2)) return h1;
      return (h1 > h2) ? h1 : h2;

  - platform: homeassistant
    name: "Temperatur_Slope"
    entity_id: sensor.wohnzimmer_temperature_slope
    id: temperatur_slope
    internal: true

number:
  # Manuelle Lüftergeschwindigkeit (für MANUAL-Modus)
  - platform: template
    name: "man Lueftergeschwindigkeit"
    id: man_fan_speed
    min_value: 0.0
    max_value: 100.0
    step: 10.0
    initial_value: ${initial_man_fan_speed}
    optimistic: true
    restore_value: true
    on_value:
      - lambda: |-
          std::string mode = id(fan_mode).current_option();
          if (mode == "manual") {
            // MANUAL: Auf manuelle Geschwindigkeit setzen
            id(apply_man_fan_speed).execute();

          } else if (mode == "auto") {
            // AUTO: Automatik-Logik ausführen
            id(automatik_steuerung).execute();
          }

select:
  # Interner Select für Betriebsmodus
  - platform: template
    id: fan_mode
    name: "Betriebsmodus"
    internal: false
    options:
      - "off"
      - "manual"
      - "auto"
    initial_option: "auto"
    optimistic: true
    restore_value: true
    on_value:
      - lambda: |-
          std::string mode = id(fan_mode).current_option();

          if (mode == "off") {
            // OFF: Lüfter ausschalten
            auto call = id(heizung_luefter).turn_off();
            call.perform();

          } else if (mode == "manual") {
            // MANUAL: Auf manuelle Geschwindigkeit setzen
            id(apply_man_fan_speed).execute();

          } else if (mode == "auto") {
            // AUTO: Automatik-Logik ausführen
            id(automatik_steuerung).execute();
          }

script:
  # Lüftergeschwindigkeit vom Number in den Fan übernehmen (nur im MANUAL-Modus)
  - id: apply_man_fan_speed
    then:
      - lambda: |-
          std::string mode = id(fan_mode).current_option();
          if (mode != "manual") return;

          int speed_value = (int)id(man_fan_speed).state;

          if (speed_value < 1) {
            id(heizung_luefter).turn_off().perform();
          } else {
            auto call = id(heizung_luefter).turn_on();
            call.set_speed(speed_value);
            call.perform();
            id(luefterleistung).publish_state(speed_value);
          }

  # Betriebsmodus wechseln: off -> manual -> auto -> off
  - id: switch_mode
    then:
      - lambda: |-
          std::string current_mode = id(fan_mode).current_option();
          std::string new_mode;

          if (current_mode == "off") new_mode = "manual";
          else if (current_mode == "manual") new_mode = "auto";
          else new_mode = "off";

          id(fan_mode).publish_state(new_mode);

  # Manuelle Geschwindigkeit in 25% Stufen ändern
  - id: adjust_manual_speed
    then:
      - lambda: |-
          std::string mode = id(fan_mode).current_option();
          if (mode != "manual") return;

          float current_speed = id(man_fan_speed).state;
          float new_speed;

          if (current_speed < 12.5) new_speed = 25.0;
          else if (current_speed < 37.5) new_speed = 50.0;
          else if (current_speed < 62.5) new_speed = 75.0;
          else if (current_speed < 87.5) new_speed = 100.0;
          else new_speed = 0.0;

          id(man_fan_speed).publish_state(new_speed);

  # Automatik-Steuerung
  - id: automatik_steuerung
    then:
      - lambda: |-
          if (id(fan_mode).current_option() != "auto") return;

          if (id(fenster_status).state) {
            id(heizung_luefter).turn_off().perform();
            id(last_speed) = 0;
            id(booster_state).publish_state("IDLE");
            return;
          }
          if (!id(raum_temp).has_state() || !id(heizung_temp).has_state() || !id(steuerung_temp).has_state()) return;
          
          float Tr = id(raum_temp).state;
          float Ts = id(steuerung_temp).state;
          float Trad = id(heizung_temp).state;
          if (isnan(Tr) || isnan(Ts) || isnan(Trad)) return;

          float e = Ts - Tr;
          float radiator_delta = Trad - Tr;
          bool heat_available = (radiator_delta >= 2.0f);
          uint32_t now = millis();
          bool recently_heating = (id(last_heat_ms) > 0) && ((now - id(last_heat_ms)) < (12u * 60u * 1000u));
          bool after_run = (!heat_available && recently_heating && radiator_delta >= 1.0f);
          
          auto *temp_slope_sensor = id(temperatur_slope);
          float slope =
            (temp_slope_sensor->has_state() && !isnan(temp_slope_sensor->state)) ? temp_slope_sensor->state : 0.0f;
          
          if (heat_available) {
            id(last_heat_ms) = now;
          }
          float min_speed = 0.0f;
          if (heat_available || after_run) {
            if (radiator_delta > 6.0f) min_speed = 40.0f;
            else if (radiator_delta > 4.0f) min_speed = 30.0f;
            else if (radiator_delta > 2.0f) min_speed = 20.0f;
          }

          float max_speed = 80.0f;
          if (e >= 1.0f) max_speed = 80.0f;
          else if (e > 0.0f) max_speed = 55.0f;
          else max_speed = 80.0f;

          if (!after_run) {
            if (slope > 0.06f) {
              max_speed = max_speed * 0.60f;
            } else if (slope > 0.03f) {
              max_speed = max_speed * 0.80f;
            }
          }
          if (heat_available || after_run) {
            max_speed = std::max(max_speed, min_speed);
          }
          float demand_speed = (heat_available && e > 0.0f) ? max_speed : 0.0f;
          float target_speed = std::max(min_speed, demand_speed);
          target_speed = std::clamp(target_speed, 0.0f, max_speed);
          if (after_run) {
            target_speed = min_speed;
          }

          int speed = 0;
          if (!heat_available && !after_run) {
            speed = 0;
          } else {
            float current = (float)id(last_speed);
            float limited = std::clamp(target_speed, current - 5.0f, current + 5.0f);
            speed = (int)roundf(limited);
            if (heat_available && speed < 1) speed = 1;
          }
          
          if (speed <= 0) {
            id(heizung_luefter).turn_off().perform();
          } else {
            id(heizung_luefter).turn_on().set_speed(speed).perform();
          }
          id(last_speed) = speed;
          id(luefterleistung).publish_state(speed);

          if (heat_available) {
            id(booster_state).publish_state("ACTIVE");
          } else if (after_run) {
            id(booster_state).publish_state("AFTER_RUN");
          } else {
            id(booster_state).publish_state("OFF");
          }
          ESP_LOGD("booster", "rad_d=%.2f e=%.2f slope=%.3f target=%.1f", radiator_delta, e, slope, target_speed);
